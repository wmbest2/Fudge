/*
 * plexser.cpp
 *
 *  Created on: Sep 3, 2008
 *      Author: wmb001
 */

#include "cppnamespace.h"
#include "cppclass.h"
#include "memfunc.h"
#include "cpptype.h"
#include "cppvar.h"
#include "plexser.h"


plexser::plexser()
	:state(plexser::skiptogen)
{
	// TODO Auto-generated constructor stub
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::plexser(const std::string& file)
	:input(new std::ifstream()), state(plexser::skiptogen), filename(file)
{
	input->open(filename.c_str());
;
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::plexser(std::ifstream* i)
	:input(i), state(plexser::skiptogen)
{
	// TODO Auto-generated constructor stub
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::~plexser() {
	// TODO Auto-generated destructor stub
}

void plexser::setFstream(const std::string& file)
{
	filename = file;
	input->open(file.c_str());
}

std::string plexser::getFileName()
{
	return filename;
}

void plexser::tokenize()
{
	dbg::trace tr("plexser", DBG_HERE);
	char current;

	input->seekg(0);
	lineNum = 1;
	columnNum = 1;
	current = getChar();
	while(!input->eof())
	{
		//std::cout << "HERE" << std::endl;
		//std::cout << current << std::endl;

		if(isspace(current))
		{
			eatWhiteSpace();
		}
		else if(current == '/' && (input->peek() == '/' || input->peek() == '*'))
		{
			eatComments();
		}
		else
			if(state == plexser::skiptogen)
			{
				NonGenerated(current);
			}
			else if(state == plexser::funcheader)
			{

				std::pair<std::string, char> current_token = nextToken(current);
				current = getChar();
				if(current_token.first == "using")
				{
					// create namespace and class object
					std::string ns_and_class = nextToken(current).first;
				std::string::size_type pos = ns_and_class.find("::", 0);
					if(pos != std::string::npos)
					{
						std::string ns = ns_and_class.substr(0, pos);
						std::string cls = ns_and_class.substr(ns.size()+2, ns_and_class.size());

						cppnamespace nspace(ns);
						getClass(cls).setNamespace(nspace);

					}
				}
				else
					buildFuncHeader(current, current_token);
			}

		current = getChar();


	}


	postProcess();
}

void plexser::NonGenerated(char first)
{
	dbg::trace tr("plexser", DBG_HERE);
	int line = lineNum;
	int col = columnNum;
	std::string junk, comment;
	char tmp = first;
	while(!input->eof() && state == skiptogen)
	{

		//std::cout << tmp;
		//junk += tmp;
		if(tmp == '/')
		{
			comment = '/';
			tmp = getChar();
			if(tmp == '*')
				{
					comment += tmp;
					bool exit = false;
					while(!exit && !input->eof())
					{
						tmp = getChar();

						if(tmp == '*' && input->peek() == '/')
						{
							comment += tmp;
							exit = true;
							tmp = getChar();
						}
						comment += tmp;
					}

				}
			if(comment == GENCOMMENT)
			{
				state = funcheader;
			}
			else
				junk += comment;
		}
		else
			junk += tmp;

		tmp = getChar();

	}


}

void plexser::buildFuncHeader(char first, std::pair<std::string, char> cur)
{
	dbg::trace tr("plexser", DBG_HERE);

	std::string cls;
	memfunc mem;
	cpptype t;
	dbg::out(dbg::info, "plexser") << dbg::indent() << cur.first << std::endl;
	if(cur.first == "const")
	{

		t.setConst(true);
		//std::cout << cur << std::endl;
		//std::cout << "return: " << cur << std::endl;
		//first = getChar();
		cur = nextToken(first);
		t.addQual(cur.first);
		mem.setReturn(t);
		first = getChar();



		cur = nextToken(first);
		first = getChar();
		//std::cout << "ident: " << cur << std::endl;

		std::string::size_type pos = cur.first.find("::", 0);
		if(pos != std::string::npos)
		{
			cls = cur.first.substr(0, pos);
			std::string name = cur.first.substr(cls.size()+2, cur.first.size());

			cppclass& curclass = getClass(cls);
			mem.setName(name);

		}
	}
	else
	{
		//std::cout << "return: " << cur << std::endl;
		dbg::out(dbg::info, "plexser") << dbg::indent() << cur.second << std::endl;
		if(cur.second != '(')
		{
			t.addQual(cur.first);
			mem.setReturn(t);
			//first = getChar();
			cur = nextToken(first);
			first = getChar();
			std::cout << "ident: " << cur.first << std::endl;

			std::string::size_type pos = cur.first.find("::", 0);
			if(pos != std::string::npos)
			{
				cls = cur.first.substr(0, pos);
				std::string name = cur.first.substr(cls.size()+2, cur.first.size());


				mem.setName(name);

			}
		}
		else // Constructor or Deconstructor
		{
			std::string::size_type pos = cur.first.find("::", 0);
			if(pos != std::string::npos)
			{
				cls = cur.first.substr(0, pos);
				std::string name = cur.first.substr(cls.size()+2, cur.first.size());

				dbg::out(dbg::info, "plexser") << dbg::indent() << name << std::endl;

				mem.setName(name);

			}
		}
	}
	cur = nextToken(first);
	std::cout << cur.second <<std::endl;
	if(cur.second != ' ' && cur.second != ',')
	{

		first = getChar();
		cur = nextToken(first);
	}
	while(cur.second == ' ' || cur.second == ',')
	{
		first = getChar();
		std::cout << "HERE: " << cur.first << std::endl;
		cpptype ptype;
		cppvar p;
		if(cur.first == "const")
		{
			ptype.setConst(true);

			cur = nextToken(first);
			std::cout << "HERE1: " << cur.first << std::endl;
			ptype.addQual(cur.first);

			first = getChar();

		}
		else
		{

			ptype.addQual(cur.first);

		}


		cur = nextToken(first);

		std::cout << "HERE--> " << cur.first << std::endl;
		p.setType(ptype);
		p.setName(cur.first);

		mem.addParam(p);
		eatWhiteSpace();
		first = getChar();

		cur = nextToken(first);


	}


	//std::cout << "HERE:: " << next.second << std::endl;
	std::string body = "";
//std::cout << "body:" << std::endl;

	if(cur.first == "const")
	{
		mem.setConst(true);
		first = input->get();
		cur = nextToken(first);
	}

	first = input->get();
	//std::cout << first << std::endl;
	body += cur.first;
	body += cur.second;
	bool has_body = false;
	int curly_count = 0;
	if(cur.second == '{')
	{
		++curly_count;
		has_body = true;
	}
	while(curly_count != 0 || !has_body)
	{
		if(first == '{')
		{
			++curly_count;
			has_body = true;
		}
		else if(first == '}')
			--curly_count;
		//std::cout << first;
		body += first;
		first = input->get();
	}
	std::cout << "Body:\n" << body << std::endl;





	mem.setBody(body);
	cppclass& curclass = getClass(cls);
	curclass.addfunc(mem);
}

void plexser::eatWhiteSpace()
{
	char current;
	current = input->peek();
	while(isspace(current) && !input->eof())
	{
		getChar();
		current = input->peek();
	}

	// YUM
}

void plexser::eatComments()
{
	char current;
	current = input->peek();

	if(current == '/')
	{
		char tmp;
		while(tmp != '\n' && !input->eof())
			tmp = getChar();

	}
	else if(current == '*')
	{
		char tmp;
		bool exit = false;
		while(!exit && !input->eof())
		{
			tmp = getChar();

			if(tmp == '*' && input->peek() == '/')
			{
				exit = true;
				tmp = getChar();
			}
		}

	}

	// YUM
}

void plexser::postProcess()
{
	std::map<std::string, cppclass>::iterator i;
	for(i = classes.begin(); i != classes.end(); ++i)
	{
		i->second.print();
	}
}


/*void plexser::eatPreProc(char first)
{
	//Eat the rest
	char tmp;
	char lastchar;
	int line = lineNum;
	int col = columnNum;
	std::string tok;
	tok += first;
	bool exit = false;
	while(!exit && !input->eof())
	{

		tmp = (char)getChar();
		tok += tmp;



		if(tmp == '\n' && lastchar != '\\')
		{
			exit = true;
		}

		lastchar = tmp;
	}

	cpptoken newToken(cpptoken::ppjunk, tok, line, col);
	cpptokens.push_back(newToken);


}
*/
char plexser::getChar()
{
	if(!input->eof())
	{
		char tmp;
		tmp = input->get();
		if(tmp == '\n'){
			++lineNum;
			columnNum = 1;
		}
		else
		{
			++columnNum;
		}
		return tmp;
	}
	return -1;

}

std::pair<std::string, char> plexser::nextToken(char first)
{
	eatWhiteSpace();
	std::string token;
	while(!input->eof() && (first != '(' && !isspace(first) && first != ')' && first != '{' && first != ';' && first != ','))
	{
		token += first;
		first = getChar();
	}

	std::pair<std::string, char> p(token, first);
	return p;
}

cppclass& plexser::getClass(const std::string& name)
{
	if(classes.find(name) == classes.end())
	{
		cppclass c;
		c.setname(name);
		classes[name] = c;
	}

	return classes[name];
}

std::vector<cppclass> plexser::getClasses()
{
	std::vector<cppclass> cls;
	std::map<std::string, cppclass>::iterator iter = classes.begin();
	for(;iter != classes.end(); ++iter)
	{
		cls.push_back(iter->second);
	}
	return cls;
}

/*cpptoken plexser::buildString()
{

	std::string tok;
	tok += '"';
	char tmp = getChar();
	while(tmp != '"' && !input->eof())
	{
		tok += tmp;
		tmp = getChar();
	}
	tok += tmp;
	//std::cout <<  "string: " << tok << std::endl;
	cpptoken newToken(cpptoken::stringliteral, tok, lineNum, columnNum);
	return newToken;
}

cpptoken plexser::buildChar()
{
	std::string tok = "'";
	char tmp = getChar();
	tok += tmp;

	//escaped characters
	if(tmp == '\\')
	{
		tmp = getChar();
		tok += tmp;
	}

	// get other '
	tmp = getChar();
	tok += tmp;
	//std::cout << tok << std::endl;
	cpptoken newToken(cpptoken::charliteral, tok, lineNum, columnNum);
	return newToken;
}

cpptoken plexser::buildKeyOrID(char first)
{
	std::string tok;
	tok += first;
	char current = input->peek();
	while((isalnum(current) || current == '_') && !input->eof())
	{
		getChar();
		tok += current;
		current = input->peek();
	}

	//std::cout << tok << std::endl;

	cpptoken::TOKENTYPE cpptokenID;
	if(keys.find(tok) != keys.end())
		cpptokenID = keys[tok].type();
	else
		cpptokenID = cpptoken::identifier;

	cpptoken newToken(cpptokenID, tok, lineNum, columnNum - tok.size());
	return newToken;

}

cpptoken plexser::buildPreProcDir(char first)
{
	cpptoken pptok = buildKeyOrID(first);
	//if(pptok.type() == cpptoken::identifier) // not needed because "if" is a keyword and a pp directive
	{
		if(preprocs.find(pptok.text()) != preprocs.end())
		{
			pptok.type(preprocs[pptok.text()].type());
			//std::cout << pptok.text() << std::endl;
			return pptok;
		}

	}
	cpptoken invalid;
	return invalid;
}

cpptoken plexser::buildNumber(char first)
{
	std::string tok;
	tok += first;
	char current = input->peek();

	int periodcount = 0;
	while((isdigit(current) || current == '.') && !input->eof())
	{
		getChar();
		if(current == '.')
		{
			if(periodcount == 0)
				++periodcount;
			else
			{
				cpptoken newToken(cpptoken::invalid, tok, lineNum, columnNum - tok.size());
				handleException(newToken);
			}
		}
		tok += current;
		current = input->peek();
	}
	//std::cout << tok << std::endl;
	cpptoken newToken(cpptoken::number, tok, lineNum, columnNum - tok.size());
	return newToken;
}

cpptoken plexser::buildTripleOp(char first)
{
	std::string tok;
	tok = first;
	tok += getChar();
	tok += getChar();
	cpptoken newToken = opers.find(tok)->second;
	newToken.line(lineNum);
	newToken.column(columnNum - 3);
	return newToken;
}

cpptoken plexser::buildDoubleOp(char first)
{
	std::string tok;
	tok = first;
	tok += getChar();
	//std::cout << tok << std::endl;
	cpptoken newToken = opers.find(tok)->second;
	newToken.line(lineNum);
	newToken.column(columnNum - 2);
	return newToken;
}

cpptoken plexser::buildSingleOp(char first)
{
	std::string tok;
	tok = first;
	//std::cout << tok << std::endl;
	cpptoken newToken = opers.find(tok)->second;
	newToken.line(lineNum);
	newToken.column(columnNum - 1);
	return newToken;
}*/


