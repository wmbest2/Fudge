/*
 * parser.cpp
 *
 *  Created on: Sep 9, 2008
 *      Author: wmb001
 */

#include "parser.h"
#include "lexer.h"
#include "memfuncstr.h"
#include "state_info.h"

parser::parser()
	:file_lexer(new lexer())
{
	// TODO Auto-generated constructor stub

}

parser::parser(const std::string& filename)
	:file_lexer(new lexer(filename))
{

}

parser::parser(lexer* lex)
	:file_lexer(lex)
{

}

parser::~parser() {
	// TODO Auto-generated destructor stub
}

void parser::parse()
{
	//std::cout << "parse" << std::endl;
	file_lexer->tokenize();
	si = new state_info();
	si->lex = file_lexer;
	si->current_token = 0;

	try
	{
		inclfile();
	}
	catch(error& e)
	{
		std::cout << "(" << e.tok.line() << ", "<< e.tok.column() << ") " << e.desc  << e.tok.text()<< std:: endl;
	}

}

void parser::cppOutput(const std::string& filename)
{
	std::ofstream of;
	of.open(filename.c_str());

	of << "/* Generated by the LVCpp Generator */\n\n\n";
	of << "#include \"" << file_lexer->getFileName() << "\"\n\n";
	of << " /*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n";
	of << " * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/\n";

	while(!(si->obj_stack.empty()))
	{
		std::vector<ref*> refs = (si->getStack<cppclass>())->cppOutput();
		si->popStack();

		for(int i = 0; i < refs.size(); ++i)
		{
			of << refs[i]->toString() << "\n";
		}
	}


	of.close();

}


/**
 * Recursive Descent Parser Functions
 * Hidden here to clean up parser class and provide easy access for future changes
 */
namespace {

	void ident(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		cpptype* t = (si->getStack<cpptype>());

		if(si->matchType(token::coloncolon))
		{
			si->matchIncr(token::coloncolon);
			t->addQual("::");
			dbg::out(dbg::info, "parser_helpers") << dbg::indent() << "::";
		}
		else
			dbg::out(dbg::info, "parser_helpers") << dbg::indent();

		while(true)
		{
			std::string name = (si->getCurrent()).text();
			t->addQual(name);
			dbg::out(dbg::info, "parser_helpers") << name ;
			si->matchIncr(token::identifier);

			if(!si->matchType(token::coloncolon))
			{
				break;
			}

			si->matchIncr(token::coloncolon);
			t->addQual("::");
			dbg::out(dbg::info, "parser_helpers") << "::";

		}
		dbg::out(dbg::info, "parser_helpers") <<std::endl;
	}

	void ifdefdir(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		if(si->matchText("ifdef"))
		{
			si->matchIncr(token::ifdef);
			si->matchIncr(token::ppjunk);
		}
		else if(si->matchText("ifndef"))
		{
			si->matchIncr(token::ifndef);
			si->matchIncr(token::ppjunk);
		}
		else if(si->matchText("endif"))
		{
			si->matchIncr(token::endif);
		}


	}
	void defdir(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::define);
		si->matchIncr(token::ppjunk);

	}

	void incldir(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::include);
		si->matchIncr(token::ppjunk);
	}


	void preproc(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::pound);
		if(si->matchText("ifdef") || si->matchText("ifndef") || si->matchText("endif"))
			ifdefdir(si);
		else if (si->matchText("define"))
			defdir(si);
		else if(si->matchText("include"))
			incldir(si);

	}

	void baseclass(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);
		std::string p = si->getCurrent().text();

		si->matchIncr(token::keyword);



		si->pushStack<cpptype>(new cpptype());

		ident(si);

		std::string i = si->getStack<cpptype>()->toString();

		si->popStack();
		si->getStack<cppclass>()->addbaseclass(p, i);
	}



	void baseclasses(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		baseclass(si);
		if(si->matchType(token::comma))
		{
			si->matchIncr(token::comma);
			baseclasses(si);
		}
	}

	void access_scope(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::keyword);
		si->matchIncr(token::colon);
	}

	void type(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		cpptype* t = (si->getStack<cpptype>());
		if(si->matchText("const"))
		{
			si->matchIncr(token::keyword, "const");
			t->setConst(true);
		}

		if(si->matchType(token::keyword))
		{
			std::string name = (si->getCurrent()).text();
			t->addQual(name);
			dbg::out(dbg::info, "parser_helpers") << dbg::indent() << "type: " << name << "\n";
			si->matchIncr(token::keyword);
		}
		else if(si->matchType(token::coloncolon) || si->matchType(token::identifier))
		{
			ident(si);
		}

		while(si->matchType(token::amp) || si->matchType(token::ast) || si->matchType(token::lsquare))
		{
			dbg::out(dbg::info, "parser_helpers") << dbg::indent() << "In qual loop" << std::endl;

			if(si->matchType(token::amp))
			{
				si->matchIncr(token::amp);
				t->addQual("&");
			}
			else if(si->matchType(token::ast))
			{
				si->matchIncr(token::ast);
				t->addQual("*");
			}
			else if(si->matchType(token::lsquare))
			{
				si->matchIncr(token::lsquare);
				si->matchIncr(token::rsquare);
				t->addQual("[]");
			}
		}
	}


	void mvardecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		cpptype* t = (si->getStack<cpptype>());

		si->matchIncr(token::identifier);
		si->matchIncr(token::semi);
	}

	void params(state_info* si)
	{
		while(!si->matchType(token::rparen))
		{
			si->pushStack<cpptype>(new cpptype());
			type(si);
			cppvar* v = new cppvar();
			cpptype* t = (si->getStack<cpptype>());
			si->popStack();
			v->setType(*t);
			v->setName(si->getCurrent().text());
			si->matchIncr(token::identifier);


			if(si->matchType(token::eq))
			{
				si->matchIncr(token::eq);
				if(si->matchType(token::stringliteral) || si->matchType(token::number) || si->matchType(token::charliteral))
				{
					v->setInit(si->getCurrent().text());
					si->matchIncr(si->getCurrent().type());
				}

			}

			memfunc* f = (si->getStack<memfunc>());
			f->addParam(*v);
			delete v;



			if(si->matchType(token::comma))
				si->matchIncr(token::comma);
		}
	}

	void mfunchead(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);
		memfunc* f = (si->getStack<memfunc>());

		f->setName(si->getCurrent().text());
		dbg::out(dbg::info, "parser_helpers") << dbg::indent() <<  si->getCurrent().text() << std::endl;
		si->matchIncr(token::identifier);
		si->matchIncr(token::lparen);
		params(si);
		si->matchIncr(token::rparen);
		if(si->matchText("const"))
			si->matchIncr(token::keyword, "const");

	}

	void mfuncdecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		if(si->matchText("virtual"))
			si->matchIncr(token::keyword, "virtual");
		else if(si->matchText("inline"))
			si->matchIncr(token::keyword, "inline");

		mfunchead(si);
		if(si->matchType(token::semi))//prototype
		{
			si->matchIncr(token::semi);
		}
		else if(si->matchType(token::eq)) // pure virtual (should virtual be a requirement here I suppose it does)
		{
			si->matchIncr(token::eq);
			si->matchIncr(token::number, "0");
			si->matchIncr(token::semi);
		}
		else if(si->matchType(token::lcurly)) //will handle inline functions
		{
			//mfuncbody         should we keep this as one unit or break it down  Its already going to be broken down but it is possible to skip everything
		}
	}

	void mconstructdecl(state_info* si)
	{
		memfunc* f = (si->getStack<memfunc>());

		f->setName(si->getCurrent().text());
		dbg::out(dbg::info, "parser_helpers") << dbg::indent() <<  si->getCurrent().text() << std::endl;
		si->matchIncr(token::identifier);
		si->matchIncr(token::lparen);
		params(si);
		si->matchIncr(token::rparen);

		if(si->matchType(token::colon))
		{
			//match initializer list
			si->matchIncr(token::colon);
			bool repeat = true;
			while(repeat)
			{
				si->matchIncr(token::identifier);
				si->matchIncr(token::lparen);
				si->matchIncr(token::identifier);
				si->matchIncr(token::rparen);
				if(!si->matchType(token::comma))
					repeat = false;
			}
		}

		if(si->matchType(token::semi))
		{
			si->matchIncr(token::semi);
		}
		else if(si->matchType(token::lcurly)) //will handle inline functions
		{
			//mfuncbody         should we keep this as one unit or break it down  Its already going to be broken down but it is possible to skip everything
		}
	}



	void mdecls(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		if(si->matchText("public") || si->matchText("private") || si->matchText("protected") )
		{
			 access_scope(si);
		}
		else if(si->matchType(token::lparen, 1))
		{
			// TODO constructor

			si->pushStack<memfunc>(new memfunc());


			mconstructdecl(si);

			memfunc* f = (si->getStack<memfunc>());
			si->popStack();
			si->getStack<cppclass>()->addfunc(*f);
		}
		else if(si->matchType(token::tilda))
		{
			//TODO Destructor
		}
		else
		{
			si->pushStack<cpptype>(new cpptype());
			type(si);

			if(si->matchType(token::lparen, 1))
			{

				cpptype* t = (si->getStack<cpptype>());
				si->popStack();
				si->pushStack<memfunc>(new memfunc());
				si->getStack<memfunc>()->setReturn(*t);

				mfuncdecl(si);

				memfunc* f = (si->getStack<memfunc>());
				si->popStack();
				si->getStack<cppclass>()->addfunc(*f);
			}
			else if (si->matchType(token::semi, 1))
			{

				cpptype* t = (si->getStack<cpptype>());
				si->popStack();
				si->pushStack<cppvar>(new cppvar());
				mvardecl(si);

			}
		}
	}

	void classbody(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::lcurly);
		while(!si->matchType(token::rcurly))
			mdecls(si);
		si->matchIncr(token::rcurly);
		si->matchIncr(token::semi);

	}

	void classdecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::keyword);
		std::string name = (si->getCurrent()).text();
		si->matchIncr(token::identifier);

		dbg::out(dbg::info, "parser_helpers") << dbg::indent() << name << std::endl;

		if(si->current_namespace.getName() != "invalid")
			(si->getStack<cppclass>())->setNamespace(si->current_namespace);

		(si->getStack<cppclass>())->setname(name);
		if(si->matchType(token::colon))
		{
			si->matchIncr(token::colon);
			baseclasses(si);
		}

		classbody(si);
	}

	void gfuncdecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);
	}

	void gvardecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);
	}

	void decls(state_info* si);

	void nspacebody(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::lcurly);
		while(!si->matchType(token::rcurly))
		{
			decls(si);
		}
		si->matchIncr(token::rcurly);
	}

	void nspacedecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		si->matchIncr(token::keyword, "namespace");
		cppnamespace cur;
		if(si->matchType(token::identifier))// this will handle empty namespaces
		{
			cur.setName((si->getCurrent()).text());

			si->matchIncr(token::identifier);
		}
		else
			cur.setName("");

		si->current_namespace = cur;

		nspacebody(si);
	}

	void usingnsdecl(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		 // using
		if(si->matchText("namespace"))
		{
				si->matchIncr(token::keyword, "namespace"); // namespace
				ident(si); // identifier
		}
		else
		{
			ident(si);
			si->matchType(token::identifier);
		}

		si->matchIncr(token::semi);
	}

	void decls(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

			if(si->matchType(token::keyword))
			{
				if(si->matchText("class") || si->matchText("struct"))
				{
					si->pushStack<cppclass>(new cppclass());
					classdecl(si);
					si->getStack<cppclass>()->print();
				}
				else if(si->matchText("namespace"))
				{
					nspacedecl(si);
				}
				else if(si->matchText("using"))
				{
					si->matchIncr(token::keyword, "using");

					if(si->matchText("namespace"))
						usingnsdecl(si);
				}
			}

		/*if(isGFunc(si))
			gfuncdecl(si);
		else
			gvardecl(si);*/
	}



	void entity(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		if(si->matchType(token::pound))
			preproc(si);
		else
			decls(si);
	}
	void entities(state_info* si)
	{
		dbg::trace tr("parser_helpers", DBG_HERE);

		while(!si->matchType(token::invalid))
		{
			entity(si);
		}
	}

}


void parser::inclfile()
{
	//std::cout << "inclfile" << std::endl;
	entities(si);
}


std::vector<cppclass> parser::getClasses()
{
	std::vector<cppclass> cls;

	std::vector<ref*> refs = (si->getStack<cppclass>())->cppOutput();
	si->popStack();

	for(int i = 0; i < refs.size(); ++i)
	{
		cls.push_back(*(cppclass*)(refs[i]));
	}

	return cls;

}
