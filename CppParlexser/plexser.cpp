/*
 * plexser.cpp
 *
 *  Created on: Sep 3, 2008
 *      Author: wmb001
 */

#include "cppnamespace.h"
#include "cppclass.h"
#include "memfunc.h"
#include "cpptype.h"
#include "cppvar.h"
#include "plexser.h"


plexser::plexser()
	:state(plexser::skiptogen)
{
	// TODO Auto-generated constructor stub
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::plexser(const std::string& file)
	:input(new std::ifstream()), state(plexser::skiptogen), filename(file)
{
	input->open(filename.c_str());
;
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::plexser(std::ifstream* i)
	:input(i), state(plexser::skiptogen)
{
	// TODO Auto-generated constructor stub
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::~plexser() {
	// TODO Auto-generated destructor stub
}

void plexser::setFstream(const std::string& file)
{
	filename = file;
	input->open(file.c_str());
}

std::string plexser::getFileName()
{
	return filename;
}

void plexser::tokenize()
{
	dbg::trace tr("plexser", DBG_HERE);
	char current;

	input->seekg(0);
	lineNum = 1;
	columnNum = 1;
	current = getChar();
	while(!input->eof())
	{
		//std::cout << "HERE" << std::endl;
		//std::cout << current << std::endl;

		if(isspace(current))
		{
			eatWhiteSpace();
		}
		else if(current == '/' && (input->peek() == '/' || input->peek() == '*'))
		{
			eatComments();
		}
		else
			if(state == plexser::skiptogen)
			{
				NonGenerated(current);
			}
			else if(state == plexser::funcheader)
			{

				input->unget();
				std::streampos pos = input->tellg();
				input->get();

				std::pair<std::string, char> current_token = nextToken(current);
				current = getChar();
				if(current_token.first == "using")
				{
					// create namespace and class object
					std::string ns_and_class = nextToken(current).first;
				std::string::size_type pos = ns_and_class.find("::", 0);
					if(pos != std::string::npos)
					{
						std::string ns = ns_and_class.substr(0, pos);
						std::string cls = ns_and_class.substr(ns.size()+2, ns_and_class.size());

						cppnamespace nspace(ns);
						getClass(cls).setNamespace(nspace);

					}
				}
				else
				{
					input->seekg(pos);
					//std::cout << "Peek: " << input->peek() << std::endl;
					buildFuncHeader(current, current_token);
				}
			}

		current = getChar();


	}


	postProcess();
}

void plexser::NonGenerated(char first)
{
	dbg::trace tr("plexser", DBG_HERE);
	int line = lineNum;
	int col = columnNum;
	std::string junk, comment;
	char tmp = first;
	while(!input->eof() && state == skiptogen)
	{

		//std::cout << tmp;
		//junk += tmp;
		if(tmp == '/')
		{
			comment = '/';
			tmp = getChar();
			if(tmp == '*')
				{
					comment += tmp;
					bool exit = false;
					while(!exit && !input->eof())
					{
						tmp = getChar();

						if(tmp == '*' && input->peek() == '/')
						{
							comment += tmp;
							exit = true;
							tmp = getChar();
						}
						comment += tmp;
					}

				}
			if(comment == GENCOMMENT)
			{
				state = funcheader;
			}
			else
				junk += comment;
		}
		else
			junk += tmp;

		tmp = getChar();

	}


}

void plexser::buildFuncHeader(char first, std::pair<std::string, char> cur)
{
	dbg::trace tr("plexser", DBG_HERE);

	std::string cls;
	memfunc mem;

	setFuncInfo(mem);

	setParamList(mem);
	setBody(mem);


	cppclass* curclass = mem.getClass();
	curclass->addfunc(mem);
}

void plexser::eatWhiteSpace()
{
	char current;
	current = input->peek();
	while(isspace(current) && !input->eof())
	{
		getChar();
		current = input->peek();
	}

	// YUM
}

void plexser::eatComments()
{
	char current;
	current = input->peek();

	if(current == '/')
	{
		char tmp;
		while(tmp != '\n' && !input->eof())
			tmp = getChar();

	}
	else if(current == '*')
	{
		char tmp;
		bool exit = false;
		while(!exit && !input->eof())
		{
			tmp = getChar();

			if(tmp == '*' && input->peek() == '/')
			{
				exit = true;
				tmp = getChar();
			}
		}

	}

	// YUM
}

void plexser::postProcess()
{
	std::map<std::string, cppclass>::iterator i;
	for(i = classes.begin(); i != classes.end(); ++i)
	{
		i->second.print();
	}
}


/*void plexser::eatPreProc(char first)
{
	//Eat the rest
	char tmp;
	char lastchar;
	int line = lineNum;
	int col = columnNum;
	std::string tok;
	tok += first;
	bool exit = false;
	while(!exit && !input->eof())
	{

		tmp = (char)getChar();
		tok += tmp;



		if(tmp == '\n' && lastchar != '\\')
		{
			exit = true;
		}

		lastchar = tmp;
	}

	cpptoken newToken(cpptoken::ppjunk, tok, line, col);
	cpptokens.push_back(newToken);


}
*/
char plexser::getChar()
{
	if(!input->eof())
	{
		char tmp;
		tmp = input->get();
		if(tmp == '\n'){
			++lineNum;
			columnNum = 1;
		}
		else
		{
			++columnNum;
		}
		return tmp;
	}
	return -1;

}

std::pair<std::string, char> plexser::nextToken(char first)
{
	eatWhiteSpace();
	std::string token;
	while(!input->eof() && (first != '(' && !isspace(first) && first != ')' && first != '{' && first != ';' && first != ','))
	{
		token += first;
		first = getChar();
	}

	std::pair<std::string, char> p(token, first);
	return p;
}

cppclass& plexser::getClass(const std::string& name)
{
	if(classes.find(name) == classes.end())
	{
		cppclass c;
		c.setname(name);
		classes[name] = c;
	}

	return classes[name];
}

std::vector<cppclass>* plexser::getClasses()
{
	dbg::trace tr("plexser", DBG_HERE);
	std::vector<cppclass>* cls = new std::vector<cppclass>();
	std::map<std::string, cppclass>::iterator iter = classes.begin();
	for(;iter != classes.end(); ++iter)
	{
		cls->push_back(iter->second);
	}
	return cls;
}

/**
 * This function will be guaranteed to start at the beginning of a function
 * it will then grab everything up to the parenthesis and make sense of it
 * ie return type and function name
 * it will leave the cursor right after the parenthesis
 */
void plexser::setFuncInfo(memfunc& f)
{
	dbg::trace tr("plexser", DBG_HERE);
	std::vector<std::string> tokens;
	char curChar = input->get();
	while(curChar != '(')
	{

		std::string token;
		while(!isspace(curChar) && curChar != '(')
		{
				token += curChar;
				curChar = input->get();
		}
		//std::cout << "Token:  " << token << std::endl;

		tokens.push_back(token);

		if(curChar != '(')
			curChar = input->get();
	}

	cpptype t;

	for(int i = 0; i < tokens.size() - 1; ++i)
	{
		if(tokens[i] == "const")
		{
			t.setConst(true);
		}
		else
		{
			t.addQual(tokens[i]);
		}
	}

	f.setReturn(t);

	//the last token will contain the name of the  function along with the class
	//other tokens are the return type
	std::string::size_type pos = tokens[tokens.size() - 1].find("::", 0);
	if(pos != std::string::npos)
	{
		std::string cls = tokens[tokens.size() - 1].substr(0, pos);
		std::string name = tokens[tokens.size() - 1].substr(cls.size()+2, tokens[tokens.size() - 1].size());


		f.setName(name);
		f.setClass(&getClass(cls));

	}
}

/**
 * This is guarenteed to be called right after the right paren and leave the cursor after the left
 */
void plexser::setParamList(memfunc& f)
{
	dbg::trace tr("plexser", DBG_HERE);
	char curChar = input->get();
	while(curChar != ')')
	{
		std::vector<std::string> tokens;
		while(curChar != ',' && curChar != ')')
		{
			std::string token;

			while(!isspace(curChar) && curChar != ',' && curChar != ')')
			{
				token += curChar;
				curChar = input->get();
			}
			//std::cout << "Token: " << token << std::endl;
			tokens.push_back(token);
			if(curChar != ')' && curChar != ',')
				curChar = input->get();
		}

		cppvar v;
		cpptype t;

		for(int i = 0; i < tokens.size() - 1; ++i)
		{
			if(tokens[i] == "const")
			{
				t.setConst(true);
			}
			else
			{
				t.addQual(tokens[i]);
			}
		}

		v.setName(tokens[tokens.size() - 1]);
		v.setType(t);
		f.addParam(v);
		if(curChar != ')')
			curChar = input->get();
	}
}

void setConst(memfunc& f);
void plexser::setBody(memfunc& f)
{

	//std::cout << "HERE:: " << next.second << std::endl;
	std::string body = "";
//std::cout << "body:" << std::endl;


	char first = input->get();
	//std::cout << first << std::endl;
	bool has_body = false;
	int curly_count = 0;

	while(curly_count != 0 || !has_body)
	{
		if(first == '{')
		{
			++curly_count;
			has_body = true;
		}
		else if(first == '}')
			--curly_count;
		//std::cout << first;
		body += first;
		first = input->get();
	}
	//std::cout << "Body:\n" << body << std::endl;





	f.setBody(body);
}

