/*
 * main.cpp
 *
 *  Created on: Sep 3, 2008
 *      Author: wmb001
 */
#include <fstream>
#include <iostream>
#include "parser.h"
#include "plexser.h"
#include "resolver.h"
#include <dbg.h>
#include <boost/filesystem/operations.hpp>
#include <sys/stat.h>
#include <sstream>
#include <exceptions.h>
#include <cstring>

namespace bfs = boost::filesystem;

struct output_config
{
	void buildConfig(int argc, char* argv[])
	{
		hfile = argv[1];
		std::cout << argc << std::endl;
		for(int i = 2; i < argc; ++i)
		{
			std::cout << argv[i] << std::endl;
			if(strcmp(argv[i], "-e") == 0)
			{
				option = 'e';
			}
			else if(strcmp(argv[i], "-c") == 0)
			{
				option = 'c';
			}
			else if(strcmp(argv[i], "-m") == 0)
			{
				option = 'm';
			}
			else if(strcmp(argv[i], "-cpp") == 0)
			{
				++i;
				cppfile = argv[i];
			}
			else if(strcmp(argv[i], "-o") == 0)
			{
				++i;
				std::cout << "OUTPUT: " << argv[i];
				outfile = argv[i];
			}
		}
	}

	std::string hfile;
	std::string cppfile;
	std::string outfile;

	char option;
};

int main(int argc, char* argv[])
{

	if(argc == 1)
	{
		std::cout << "Usage: fudge filepath.h [-e | -c | -m][-cpp filepath.cpp] -o ouputfile.cpp " << std::endl;
		std::cout << "\t\t-e\t Empty Function Bodies\n";
		std::cout << "\t\t-c\t Copy Default Function Bodies\n";
		std::cout << "\t\t-m\t Manual Matching after Default Copy of Function Bodies\n";
	}
	else
	{
		output_config oc;
		oc.buildConfig(argc, argv);
		std::cout << oc.hfile << std::endl;
		try
		{
			parser my_parser(oc.hfile);
			my_parser.parse();

		std::cout << "Before Copy" << std::endl;
		struct stat stFileInfo;
		bfs::path outpath(oc.outfile);
		if(bfs::exists(outpath))
		{
			bool filebackedup = false;
			int count = 0;

			while(filebackedup == false)
			{
				try
				{
					std::stringstream tack;

					if(count != 0)
					{
						tack << "_" << count;
					}
					std::string outback = oc.outfile + ".bak" + tack.str();
					bfs::path outbackpath(outback);
					std::cout << "RENAMING : " << oc.outfile << " to " << outback << std::endl;
					bfs::copy_file(outpath, outbackpath);
					filebackedup = true;
				}
				catch(bfs::filesystem_error e)
				{
					count++;
				}


			}
		}
		std::cout << "HERE" << std::endl;
		if(oc.cppfile != "" && oc.option == 'c')
		{
			plexser my_plexser(oc.cppfile);
			my_plexser.tokenize();

			resolver my_resolver(&my_parser, &my_plexser);
			my_resolver.makeMatches();

			output_object o = my_resolver.finalize();

			std::ofstream of;


			of.open(oc.outfile.c_str());

			of << "/* Generated by the LVCpp Generator */\n\n\n";
			of << "#include \"" << oc.hfile << "\"\n\n";
			of << " /*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n";
			of << " * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/\n\n";

			for(int i = 0; i < o.functions.size(); ++i)
			{
				of << o.functions[i].first << o.functions[i].second << std::endl << std::endl;
			}

			of.close();
		}
		else
		{
			my_parser.cppOutput(oc.outfile);
		}
		}catch (file_not_found& e)
		{
			std::cout << e.file_name << std::endl;
		}
	}
	return 0;
}
