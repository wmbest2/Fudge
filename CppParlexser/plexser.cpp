/*
 * plexser.cpp
 *
 *  Created on: Sep 3, 2008
 *      Author: wmb001
 */

#include "cppnamespace.h"
#include "cppclass.h"
#include "memfunc.h"
#include "cpptype.h"
#include "cppvar.h"
#include "plexser.h"


plexser::plexser()
	:state(plexser::skiptogen)
{
	// TODO Auto-generated constructor stub
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::plexser(const std::string& file)
	:input(new std::ifstream()), state(plexser::skiptogen), filename(file)
{
	input->open(filename.c_str());
;
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::plexser(std::ifstream* i)
	:input(i), state(plexser::skiptogen)
{
	// TODO Auto-generated constructor stub
	GENCOMMENT = "/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\\\n *      Do not Touch Headers Below       *\n * Generated by Bills CPP file generator *\n \\*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*/";
}

plexser::~plexser() {
	// TODO Auto-generated destructor stub
}

void plexser::setFstream(const std::string& file)
{
	filename = file;
	input->open(file.c_str());
}

std::string plexser::getFileName()
{
	return filename;
}

void plexser::tokenize()
{
	char current;

	input->seekg(0);
	lineNum = 1;
	columnNum = 1;
	current = getChar();
	while(!input->eof())
	{
		//std::cout << "HERE" << std::endl;
		//std::cout << current << std::endl;

		if(isspace(current))
		{
			eatWhiteSpace();
		}
		else if(current == '/' && (input->peek() == '/' || input->peek() == '*'))
		{
			eatComments();
		}
		else
			if(state == plexser::skiptogen)
			{
				NonGenerated(current);

			}
			else if(state == plexser::funcheader)
			{

				std::string current_token = nextToken(current).first;
				current = getChar();
				if(current_token == "using")
				{
					// create namespace and class object
					std::string ns_and_class = nextToken(current).first;
				std::string::size_type pos = ns_and_class.find("::", 0);
					if(pos != std::string::npos)
					{
						std::string ns = ns_and_class.substr(0, pos);
						std::string cls = ns_and_class.substr(ns.size()+2, ns_and_class.size());

						cppnamespace nspace(ns);
						getClass(cls).setNamespace(nspace);

					}
				}
				else
					buildFuncHeader(current, current_token);
			}

		current = getChar();


	}


	postProcess();
}

void plexser::NonGenerated(char first)
{
	int line = lineNum;
	int col = columnNum;
	std::string junk, comment;
	char tmp = first;
	while(!input->eof() && state == skiptogen)
	{

		//std::cout << tmp;
		//junk += tmp;
		if(tmp == '/')
		{
			comment = '/';
			tmp = getChar();
			if(tmp == '*')
				{
					comment += tmp;
					bool exit = false;
					while(!exit && !input->eof())
					{
						tmp = getChar();

						if(tmp == '*' && input->peek() == '/')
						{
							comment += tmp;
							exit = true;
							tmp = getChar();
						}
						comment += tmp;
					}

				}
			if(comment == GENCOMMENT)
			{
				state = funcheader;
			}
			else
				junk += comment;
		}
		else
			junk += tmp;

		tmp = getChar();

	}


}

void plexser::buildFuncHeader(char first, std::string cur)
{
	std::pair<std::string, char> next = nextToken(first);

	std::string cls;
	memfunc mem;
	cpptype t;
	if(cur == "const")
	{

		t.setConst(true);
		//std::cout << cur << std::endl;
		cur = next.first;
		//std::cout << "return: " << cur << std::endl;
		t.addQual(cur);
		mem.setReturn(t);
		first = getChar();



		next = nextToken(first);
		first = getChar();
		cur = next.first;
		//std::cout << "ident: " << cur << std::endl;

		std::string::size_type pos = cur.find("::", 0);
		if(pos != std::string::npos)
		{
			cls = cur.substr(0, pos);
			std::string name = cur.substr(cls.size()+2, cur.size());

			cppclass& curclass = getClass(cls);
			mem.setName(name);

		}
	}
	else
	{
		//std::cout << "return: " << cur << std::endl;
		t.addQual(cur);
		mem.setReturn(t);
		first = getChar();

		cur = next.first;
		//std::cout << "ident: " << cur << std::endl;

		std::string::size_type pos = cur.find("::", 0);
		if(pos != std::string::npos)
		{
			cls = cur.substr(0, pos);
			std::string name = cur.substr(cls.size()+2, cur.size());


			mem.setName(name);

		}
	}
	next = nextToken(first);
	cur = next.first;
	if(next.second != ' ' && next.second != ',')
	{
		first = getChar();
		next = nextToken(first);
	}
	while(next.second == ' ' || next.second == ',')
	{
		first = getChar();
		//std::cout << "HERE: " << next.first << std::endl;
		cpptype ptype;
		cppvar p;
		if(cur == "const")
		{
			ptype.setConst(true);

			next = nextToken(first);
			cur = next.first;
			ptype.addQual(cur);
			first = getChar();

		}
		else
		{

			ptype.addQual(cur);

		}


		next = nextToken(first);

		cur = next.first;
		//std::cout << "HERE--> " << next.first << std::endl;
		p.setType(ptype);
		p.setName(cur);
		mem.addParam(p);
		eatWhiteSpace();
		first = getChar();

		next = nextToken(first);
		cur = next.first;

	}


	//std::cout << "HERE:: " << next.second << std::endl;
	std::string body = "";
//std::cout << "body:" << std::endl;

	if(next.second == '{')
	{
		first = input->get();
		while(first != '}')
		{
			//std::cout << first;
			body += first;
			first = input->get();
		}
	}


	mem.setBody(body);
	cppclass& curclass = getClass(cls);
	curclass.addfunc(mem);
}

void plexser::eatWhiteSpace()
{
	char current;
	current = input->peek();
	while(isspace(current) && !input->eof())
	{
		getChar();
		current = input->peek();
	}

	// YUM
}

void plexser::eatComments()
{
	char current;
	current = input->peek();

	if(current == '/')
	{
		char tmp;
		while(tmp != '\n' && !input->eof())
			tmp = getChar();

	}
	else if(current == '*')
	{
		char tmp;
		bool exit = false;
		while(!exit && !input->eof())
		{
			tmp = getChar();

			if(tmp == '*' && input->peek() == '/')
			{
				exit = true;
				tmp = getChar();
			}
		}

	}

	// YUM
}

void plexser::postProcess()
{
	std::map<std::string, cppclass>::iterator i;
	for(i = classes.begin(); i != classes.end(); ++i)
	{
		i->second.print();
	}
}


/*void plexser::eatPreProc(char first)
{
	//Eat the rest
	char tmp;
	char lastchar;
	int line = lineNum;
	int col = columnNum;
	std::string tok;
	tok += first;
	bool exit = false;
	while(!exit && !input->eof())
	{

		tmp = (char)getChar();
		tok += tmp;



		if(tmp == '\n' && lastchar != '\\')
		{
			exit = true;
		}

		lastchar = tmp;
	}

	cpptoken newToken(cpptoken::ppjunk, tok, line, col);
	cpptokens.push_back(newToken);


}
*/
char plexser::getChar()
{
	if(!input->eof())
	{
		char tmp;
		tmp = input->get();
		if(tmp == '\n'){
			++lineNum;
			columnNum = 1;
		}
		else
		{
			++columnNum;
		}
		return tmp;
	}
	return -1;

}

std::pair<std::string, char> plexser::nextToken(char first)
{
	eatWhiteSpace();
	std::string token;
	while(!input->eof() && (first != '(' && !isspace(first) && first != ')' && first != '{' && first != ';' && first != ','))
	{
		token += first;
		first = getChar();
	}

	std::pair<std::string, char> p(token, first);
	return p;
}

cppclass& plexser::getClass(const std::string& name)
{
	if(classes.find(name) == classes.end())
	{
		cppclass c;
		c.setname(name);
		classes[name] = c;
	}

	return classes[name];
}

/*cpptoken plexser::buildString()
{

	std::string tok;
	tok += '"';
	char tmp = getChar();
	while(tmp != '"' && !input->eof())
	{
		tok += tmp;
		tmp = getChar();
	}
	tok += tmp;
	//std::cout <<  "string: " << tok << std::endl;
	cpptoken newToken(cpptoken::stringliteral, tok, lineNum, columnNum);
	return newToken;
}

cpptoken plexser::buildChar()
{
	std::string tok = "'";
	char tmp = getChar();
	tok += tmp;

	//escaped characters
	if(tmp == '\\')
	{
		tmp = getChar();
		tok += tmp;
	}

	// get other '
	tmp = getChar();
	tok += tmp;
	//std::cout << tok << std::endl;
	cpptoken newToken(cpptoken::charliteral, tok, lineNum, columnNum);
	return newToken;
}

cpptoken plexser::buildKeyOrID(char first)
{
	std::string tok;
	tok += first;
	char current = input->peek();
	while((isalnum(current) || current == '_') && !input->eof())
	{
		getChar();
		tok += current;
		current = input->peek();
	}

	//std::cout << tok << std::endl;

	cpptoken::TOKENTYPE cpptokenID;
	if(keys.find(tok) != keys.end())
		cpptokenID = keys[tok].type();
	else
		cpptokenID = cpptoken::identifier;

	cpptoken newToken(cpptokenID, tok, lineNum, columnNum - tok.size());
	return newToken;

}

cpptoken plexser::buildPreProcDir(char first)
{
	cpptoken pptok = buildKeyOrID(first);
	//if(pptok.type() == cpptoken::identifier) // not needed because "if" is a keyword and a pp directive
	{
		if(preprocs.find(pptok.text()) != preprocs.end())
		{
			pptok.type(preprocs[pptok.text()].type());
			//std::cout << pptok.text() << std::endl;
			return pptok;
		}

	}
	cpptoken invalid;
	return invalid;
}

cpptoken plexser::buildNumber(char first)
{
	std::string tok;
	tok += first;
	char current = input->peek();

	int periodcount = 0;
	while((isdigit(current) || current == '.') && !input->eof())
	{
		getChar();
		if(current == '.')
		{
			if(periodcount == 0)
				++periodcount;
			else
			{
				cpptoken newToken(cpptoken::invalid, tok, lineNum, columnNum - tok.size());
				handleException(newToken);
			}
		}
		tok += current;
		current = input->peek();
	}
	//std::cout << tok << std::endl;
	cpptoken newToken(cpptoken::number, tok, lineNum, columnNum - tok.size());
	return newToken;
}

cpptoken plexser::buildTripleOp(char first)
{
	std::string tok;
	tok = first;
	tok += getChar();
	tok += getChar();
	cpptoken newToken = opers.find(tok)->second;
	newToken.line(lineNum);
	newToken.column(columnNum - 3);
	return newToken;
}

cpptoken plexser::buildDoubleOp(char first)
{
	std::string tok;
	tok = first;
	tok += getChar();
	//std::cout << tok << std::endl;
	cpptoken newToken = opers.find(tok)->second;
	newToken.line(lineNum);
	newToken.column(columnNum - 2);
	return newToken;
}

cpptoken plexser::buildSingleOp(char first)
{
	std::string tok;
	tok = first;
	//std::cout << tok << std::endl;
	cpptoken newToken = opers.find(tok)->second;
	newToken.line(lineNum);
	newToken.column(columnNum - 1);
	return newToken;
}*/


